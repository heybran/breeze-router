{"version":3,"file":"BreezeRouter.min.js","sources":["../src/index.js"],"sourcesContent":["// @ts-check\n\n/**\n * Class representing a router.\n */\nexport default class BreezeRouter {\n  /**\n   * Creates a new BreezeRouter instance.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * Object containing all registered routes.\n     * @type {Object.<string, Function>} \n     * @private\n     */\n    this._routes = {};\n\n    /**\n     * The previous route that was navigated to\n     * @type {Object|null}\n     * @private\n     */\n    this._previousRoute = null;\n\n    /**\n     * Flag indicating whether this is the first initial page load.\n     * @type {boolean}\n     * @private\n     */\n    this._isInitialLoad = false;\n\n    // Bind event listeners\n    window.addEventListener('popstate', this._onChanged.bind(this));\n    document.body.addEventListener('click', this._handleClick.bind(this));\n  }\n\n  /**\n   * Initializes the router by triggering the initial navigation event.\n   * @returns {void}\n   */\n  init() {\n    this._onChanged();\n  }\n\n  /**\n   * Adds a new route to the router.\n   * @param {string} route - The route path to add.\n   * @param {Function} handler - The async function to handle the route\n   * @returns {BreezeRouter} The BreezeRouter instance.\n   */\n  add(route, handler) {\n    if (this._routes[route]) {\n      return console.warn(`Route already exists: ${route}`);\n    }\n\n    this._routes[route] = {\n      path: route,\n      handler\n    };\n\n    return this;\n  }\n\n  /**\n   * Navigates to the specified URL.\n   * @param {string} url - The URL to navigate to\n   * @returns {void}\n   */\n  navigateTo(url) {\n    window.history.pushState({url}, '', url);\n    this._onChanged();\n  }\n\n  async _onChanged() {\n    const path = window.location.pathname;\n    const { route, params } = this._matchUrlToRoute(path);\n\n    if (!route) {\n      return;\n    }\n\n    if (typeof route.handler === \"function\" && route.handler.constructor.name.toLowerCase() === \"function\") {\n      route.handler({ route, param });\n    } \n\n    if (typeof route.handler === \"function\" && route.handler.constructor.name.toLowerCase() === \"asyncfunction\") {\n      await route.handler({ route, params });\n    }\n  }\n\n  // @param {string} url\n  _matchUrlToRoute(url) {\n    // params will be storing some information of matched route\n    const params = {};\n\n    // If url ends with \"/\", e.g. \"/project/edit/123/\",\n    // then remove the trailing slash using replace() method with a regular expression.\n    if (url.endsWith('/')) {\n      url = url.replace(/\\/$/, '');\n    }\n\n    // When we visit url: /project/edit/123,\n    // first we need to figure out which route match the url pattern.\n    const matchedRoute = Object.keys(this._routes).find((route) => {\n      // '/dashboard' will not match '/project/edit/123'\n      // as they have different length if we compare them after split with \"/\".\n      if (url.split('/').length !== route.split('/').length) {\n        return false;\n      }\n\n      // '/project/edit/:id' => [ \"project\", \"edit\", \":id\" ]\n      let routeSegments = route.split('/').slice(1);\n      // '/project/edit/123' => [ \"project\", \"edit\", \"123\" ]\n      let urlSegments = url.split('/').slice(1);\n\n      // If each segment in the url matches the corresponding segment in the route path,\n      // or the route path segment starts with a ':' then the route is matched.\n      const match = routeSegments.every((segment, i) => {\n        return segment === urlSegments[i] || segment.startsWith(':');\n      });\n\n      // If the route matches the URL, pull out any params from the URL.\n      if (match) {\n        routeSegments.forEach((segment, i) => {\n          if (segment[0] === ':') {\n            const propName = segment.slice(1);\n            params[propName] = decodeURIComponent(urlSegments[i]);\n          }\n        });\n      }\n\n      return match;\n    });\n\n    return { route: this._routes[matchedRoute], params };\n  }\n\n  _handleClick() {\n    \n  }\n} "],"names":["BreezeRouter","constructor","this","_routes","_previousRoute","_isInitialLoad","window","addEventListener","_onChanged","bind","document","body","_handleClick","init","add","route","handler","console","warn","path","navigateTo","url","history","pushState","async","location","pathname","params","_matchUrlToRoute","name","toLowerCase","param","endsWith","replace","matchedRoute","Object","keys","find","split","length","routeSegments","slice","urlSegments","match","every","segment","i","startsWith","forEach","propName","decodeURIComponent"],"mappings":"AAKe,MAAMA,EAKnBC,cAMEC,KAAKC,QAAU,GAOfD,KAAKE,eAAiB,KAOtBF,KAAKG,gBAAiB,EAGtBC,OAAOC,iBAAiB,WAAYL,KAAKM,WAAWC,KAAKP,OACzDQ,SAASC,KAAKJ,iBAAiB,QAASL,KAAKU,aAAaH,KAAKP,MAChE,CAMDW,OACEX,KAAKM,YACN,CAQDM,IAAIC,EAAOC,GACT,OAAId,KAAKC,QAAQY,GACRE,QAAQC,KAAK,yBAAyBH,MAG/Cb,KAAKC,QAAQY,GAAS,CACpBI,KAAMJ,EACNC,WAGKd,KACR,CAODkB,WAAWC,GACTf,OAAOgB,QAAQC,UAAU,CAACF,OAAM,GAAIA,GACpCnB,KAAKM,YACN,CAEDgB,mBACE,MAAML,EAAOb,OAAOmB,SAASC,UACvBX,MAAEA,EAAKY,OAAEA,GAAWzB,KAAK0B,iBAAiBT,GAE3CJ,IAIwB,mBAAlBA,EAAMC,SAA2E,aAAjDD,EAAMC,QAAQf,YAAY4B,KAAKC,eACxEf,EAAMC,QAAQ,CAAED,QAAOgB,cAGI,mBAAlBhB,EAAMC,SAA2E,kBAAjDD,EAAMC,QAAQf,YAAY4B,KAAKC,qBAClEf,EAAMC,QAAQ,CAAED,QAAOY,WAEhC,CAGDC,iBAAiBP,GAEf,MAAMM,EAAS,CAAA,EAIXN,EAAIW,SAAS,OACfX,EAAMA,EAAIY,QAAQ,MAAO,KAK3B,MAAMC,EAAeC,OAAOC,KAAKlC,KAAKC,SAASkC,MAAMtB,IAGnD,GAAIM,EAAIiB,MAAM,KAAKC,SAAWxB,EAAMuB,MAAM,KAAKC,OAC7C,OAAO,EAIT,IAAIC,EAAgBzB,EAAMuB,MAAM,KAAKG,MAAM,GAEvCC,EAAcrB,EAAIiB,MAAM,KAAKG,MAAM,GAIvC,MAAME,EAAQH,EAAcI,OAAM,CAACC,EAASC,IACnCD,IAAYH,EAAYI,IAAMD,EAAQE,WAAW,OAa1D,OATIJ,GACFH,EAAcQ,SAAQ,CAACH,EAASC,KAC9B,GAAmB,MAAfD,EAAQ,GAAY,CACtB,MAAMI,EAAWJ,EAAQJ,MAAM,GAC/Bd,EAAOsB,GAAYC,mBAAmBR,EAAYI,GACnD,KAIEH,CAAK,IAGd,MAAO,CAAE5B,MAAOb,KAAKC,QAAQ+B,GAAeP,SAC7C,CAEDf,eAEC"}